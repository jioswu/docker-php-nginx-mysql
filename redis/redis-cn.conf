# Redis 配置文件示例

# 注意单位：当需要内存大小时，可以以通常的形式指定：
#
# 1k => 1000 字节
# 1kb => 1024 字节
# 1m => 1000000 字节
# 1mb => 1024*1024 字节
# 1g => 1000000000 字节
# 1gb => 1024*1024*1024 字节
#
# 单位不区分大小写，因此 1GB 1Gb 1gB 都是相同的。

################################## 包含文件 ###################################

# 在此处包含一个或多个其他配置文件。如果你有一个标准的模板适用于所有 Redis 服务器，
# 但还需要自定义一些每个服务器的设置，这将非常有用。包含文件可以包含其他文件，
# 因此请明智地使用此功能。
#
# 注意：选项 "include" 不会被管理员或 Redis Sentinel 的 "CONFIG REWRITE" 命令重写。
# 由于 Redis 始终使用最后处理的行作为配置指令的值，因此最好将包含文件放在此文件的开头，
# 以避免在运行时覆盖配置更改。
#
# 如果你希望使用包含文件来覆盖配置选项，最好将包含文件放在最后一行。
#
# include .\path\to\local.conf
# include c:\path\to\other.conf

################################ 通用配置  #####################################

# 在 Windows 上，守护进程和 pidfile 不受支持。
# 但是，你可以将 Redis 作为 Windows 服务运行，并指定一个日志文件。
# 日志文件将包含 pid。

# 接受连接的指定端口，默认为 6379。
# 如果指定端口 0，Redis 将不会监听 TCP 套接字。
port 6379

# TCP listen() 积压。
#
# 在高请求每秒的环境中，你需要一个高积压以避免慢客户端连接问题。
# 请注意，Linux 内核会静默将其截断为 /proc/sys/net/core/somaxconn 的值，
# 因此请确保提高 somaxconn 和 tcp_max_syn_backlog 的值以达到预期效果。
tcp-backlog 511

# 默认情况下，Redis 监听服务器上所有可用网络接口的连接。
# 可以使用 "bind" 配置指令监听一个或多个接口，后跟一个或多个 IP 地址。
#
# 示例：
#
# bind 192.168.1.100 10.0.0.1
# bind 127.0.0.1

# 指定用于监听传入连接的 Unix 套接字的路径。
# 没有默认值，因此如果未指定，Redis 将不会监听 Unix 套接字。
#
# unixsocket /tmp/redis.sock
# unixsocketperm 700

# 在客户端空闲 N 秒后关闭连接（0 表示禁用）
timeout 0

# TCP keepalive。
#
# 如果非零，则在无通信时使用 SO_KEEPALIVE 向客户端发送 TCP ACK。
# 这有两个原因：
#
# 1) 检测死对等点。
# 2) 从中间网络设备的角度保持连接活动。
#
# 在 Linux 上，指定的值（以秒为单位）是用于发送 ACK 的周期。
# 请注意，关闭连接需要双倍的时间。
# 在其他内核上，周期取决于内核配置。
#
# 此选项的合理值为 60 秒。
tcp-keepalive 0

# 指定服务器的详细级别。
# 可以是以下之一：
# debug（大量信息，适用于开发/测试）
# verbose（许多很少有用的信息，但不像调试级别那样混乱）
# notice（适度详细，可能是生产环境中需要的）
# warning（仅记录非常重要/关键的消息）
loglevel notice

# 指定日志文件名。也可以使用 'stdout' 强制 Redis 记录到标准输出。
logfile ""

# 要启用记录到 Windows 事件日志，只需将 'syslog-enabled' 设置为 yes，
# 并可选地更新其他 syslog 参数以满足你的需求。
# 如果 Redis 作为 Windows 服务安装并启动，这将自动启用。
# syslog-enabled no

# 指定 Windows 应用程序日志中事件的源名称。
# syslog-ident redis

# 设置数据库的数量。默认数据库是 DB 0，你可以使用 SELECT <dbid> 在每个连接的基础上
# 选择一个不同的数据库，其中 dbid 是介于 0 和 'databases'-1 之间的数字。
databases 16

################################ 快照  ################################
#
# 将数据库保存到磁盘：
#
#   save <seconds> <changes>
#
#   如果给定的秒数和给定的写操作次数都发生，则将保存数据库。
#
#   在下面的示例中，行为将是：
#   在 900 秒（15 分钟）后，如果至少有 1 个键更改
#   在 300 秒（5 分钟）后，如果至少有 10 个键更改
#   在 60 秒后，如果至少有 10000 个键更改
#
#   注意：你可以通过注释掉所有 "save" 行来完全禁用保存。
#
#   也可以通过添加一个带有单个空字符串参数的 save 指令来删除所有先前配置的保存点，
#   如下例所示：
#
#   save ""

save 900 1
save 300 10
save 60 10000

# 默认情况下，如果启用了 RDB 快照（至少有一个保存点）并且最新的后台保存失败，
# Redis 将停止接受写入。这将使用户意识到（以一种严厉的方式）数据没有正确持久化到磁盘，
# 否则可能没有人注意到，并且会发生一些灾难。
#
# 如果后台保存过程再次开始工作，Redis 将自动再次允许写入。
#
# 但是，如果你已经设置了适当的 Redis 服务器监控和持久性，你可能希望禁用此功能，
# 以便 Redis 即使在磁盘、权限等方面出现问题时也能继续正常工作。
stop-writes-on-bgsave-error yes

# 在转储 .rdb 数据库时使用 LZF 压缩字符串对象？
# 默认情况下，这设置为 'yes'，因为它几乎总是一个胜利。
# 如果你希望在保存子进程中节省一些 CPU，请将其设置为 'no'，
# 但如果你有可压缩的值或键，数据集可能会更大。
rdbcompression yes

# 从 RDB 版本 5 开始，CRC64 校验和放置在文件的末尾。
# 这使得格式更能抵抗损坏，但在保存和加载 RDB 文件时会付出性能代价（大约 10%），
# 因此你可以禁用它以获得最大性能。
#
# 禁用校验和创建的 RDB 文件的校验和为零，这将告诉加载代码跳过检查。
rdbchecksum yes

# 转储数据库的文件名
dbfilename dump.rdb

# 工作目录。
#
# 数据库将写入此目录中，使用上面指定的 'dbfilename' 配置指令。
# 
# 追加文件也将在此目录中创建。
# 
# 请注意，你必须在此处指定一个目录，而不是文件名。
dir ./

################################# 复制 #################################

# 主从复制。使用 slaveof 使 Redis 实例成为另一个 Redis 服务器的副本。
# 关于 Redis 复制的一些需要尽快理解的事情：
#
# 1) Redis 复制是异步的，但你可以配置主服务器在看起来未连接到至少给定数量的从服务器时停止接受写入。
# 2) 如果复制链接丢失了相对较短的时间，Redis 从服务器能够与主服务器执行部分重新同步。
#    你可能希望根据你的需求配置复制积压大小（参见此文件的下一部分）为一个合理的值。
# 3) 复制是自动的，不需要用户干预。在网络分区后，从服务器会自动尝试重新连接到主服务器并与其重新同步。
#
# slaveof <masterip> <masterport>

# 如果主服务器受密码保护（使用下面的 "requirepass" 配置指令），
# 可以告诉从服务器在开始复制同步过程之前进行身份验证，否则主服务器将拒绝从服务器的请求。
#
# masterauth <master-password>

# 当从服务器失去与主服务器的连接，或者复制仍在进行时，从服务器可以以两种不同的方式行事：
#
# 1) 如果 slave-serve-stale-data 设置为 'yes'（默认值），从服务器仍将回复客户端请求，
#    可能使用过时的数据，或者如果这是第一次同步，则数据集可能为空。
#
# 2) 如果 slave-serve-stale-data 设置为 'no'，从服务器将回复所有类型的命令，
#    除了 INFO 和 SLAVEOF，返回错误 "SYNC with master in progress"。
#
slave-serve-stale-data yes

# 你可以配置从服务器实例接受写入或不接受写入。对从服务器实例进行写入可能对存储一些临时数据有用
# （因为在与主服务器重新同步后，写入从服务器的数据将很容易被删除），
# 但如果客户端由于配置错误而写入从服务器，也可能导致问题。
#
# 从 Redis 2.6 开始，默认情况下从服务器是只读的。
#
# 注意：只读从服务器不设计为暴露给互联网上的不受信任的客户端。
# 它只是防止实例被滥用的保护层。
# 仍然，默认情况下，只读从服务器导出所有管理命令，如 CONFIG、DEBUG 等。
# 你可以使用 'rename-command' 在一定程度上提高只读从服务器的安全性，
# 以隐藏所有管理/危险命令。
slave-read-only yes

# 复制 SYNC 策略：磁盘或套接字。
#
# -------------------------------------------------------
# 警告：目前无磁盘复制是实验性的
# -------------------------------------------------------
#
# 新的从服务器和重新连接的从服务器如果无法继续复制过程，仅接收差异，
# 则需要执行所谓的“完全同步”。RDB 文件从主服务器传输到从服务器。
# 传输可以通过两种不同的方式进行：
#
# 1) 磁盘支持：Redis 主服务器创建一个新进程，将 RDB 文件写入磁盘。
#    稍后，父进程将文件逐步传输到从服务器。
# 2) 无磁盘：Redis 主服务器创建一个新进程，直接将 RDB 文件写入从服务器套接字，
#    完全不接触磁盘。
#
# 使用磁盘支持的复制，在生成 RDB 文件时，更多的从服务器可以排队，
# 并在当前生成 RDB 文件的子进程完成其工作后立即为其提供服务。
# 使用无磁盘复制，一旦传输开始，新到达的从服务器将排队，
# 并在当前传输终止时开始新的传输。
#
# 使用无磁盘复制时，主服务器在开始传输之前等待可配置的时间（以秒为单位），
# 希望多个从服务器到达并且传输可以并行化。
#
# 对于慢速磁盘和快速（大带宽）网络，无磁盘复制效果更好。
repl-diskless-sync no

# 启用无磁盘复制时，可以配置服务器在生成通过套接字传输 RDB 的子进程之前等待的延迟。
#
# 这很重要，因为一旦传输开始，就无法为新到达的从服务器提供服务，
# 它们将排队等待下一次 RDB 传输，因此服务器等待延迟以让更多从服务器到达。
#
# 延迟以秒为单位指定，默认情况下为 5 秒。要完全禁用它，只需将其设置为 0 秒，
# 传输将尽快开始。
repl-diskless-sync-delay 5

# 从服务器以预定义的时间间隔向服务器发送 PING。可以使用 repl_ping_slave_period 选项更改此间隔。
# 默认值为 10 秒。
#
# repl-ping-slave-period 10

# 以下选项设置复制的超时时间：
#
# 1) 从服务器的角度，SYNC 期间的批量传输 I/O。
# 2) 从服务器的角度，主服务器的超时（数据、PING）。
# 3) 主服务器的角度，从服务器的超时（REPLCONF ACK PING）。
#
# 确保此值大于为 repl-ping-slave-period 指定的值非常重要，
# 否则每次主服务器和从服务器之间的流量较低时都会检测到超时。
#
# repl-timeout 60

# 在 SYNC 后禁用从服务器套接字上的 TCP_NODELAY？
#
# 如果选择 "yes"，Redis 将使用较少的 TCP 数据包和较少的带宽向从服务器发送数据。
# 但这可能会增加数据出现在从服务器端的延迟，使用默认配置的 Linux 内核最多可达 40 毫秒。
#
# 如果选择 "no"，数据出现在从服务器端的延迟将减少，但复制将使用更多带宽。
#
# 默认情况下，我们优化低延迟，但在非常高的流量条件下或当主服务器和从服务器相距多跳时，
# 将其设置为 "yes" 可能是一个好主意。
repl-disable-tcp-nodelay no

# 设置复制积压大小。积压是一个缓冲区，当从服务器断开连接一段时间时，
# 它会累积从服务器数据，以便当从服务器想要重新连接时，通常不需要完全重新同步，
# 而是部分重新同步就足够了，只需传递从服务器在断开连接时错过的数据部分。
#
# 复制积压越大，从服务器可以断开连接的时间越长，并且稍后能够执行部分重新同步。
#
# 只有在至少有一个从服务器连接时才会分配积压。
#
# repl-backlog-size 1mb

# 在主服务器不再连接从服务器一段时间后，积压将被释放。
# 以下选项配置从最后一个从服务器断开连接开始，需要经过多少秒才能释放积压缓冲区。
#
# 值为 0 表示永远不释放积压。
#
# repl-backlog-ttl 3600

# 从服务器优先级是由 Redis 在 INFO 输出中发布的整数。
# Redis Sentinel 使用它来选择从服务器以在主服务器不再正常工作时提升为主服务器。
#
# 优先级较低的从服务器被认为更适合提升，因此例如如果有三个从服务器优先级分别为 10、100、25，
# Sentinel 将选择优先级为 10 的从服务器，即最低的。
#
# 但是，优先级为 0 的特殊标记表示从服务器无法执行主服务器的角色，
# 因此优先级为 0 的从服务器永远不会被 Redis Sentinel 选择进行提升。
#
# 默认优先级为 100。
slave-priority 100

# 如果连接的从服务器少于 N 个，且延迟小于或等于 M 秒，主服务器可以停止接受写入。
#
# N 个从服务器需要处于“在线”状态。
#
# 延迟以秒为单位，必须 <= 指定的值，从从服务器接收的最后一个 PING 计算，
# 通常每秒发送一次。
#
# 此选项不保证 N 个从服务器将接受写入，但如果可用的从服务器不足，
# 它将限制丢失写入的暴露窗口为指定的秒数。
#
# 例如，要求至少 3 个从服务器延迟 <= 10 秒：
#
# min-slaves-to-write 3
# min-slaves-max-lag 10
#
# 将其中一个设置为 0 将禁用该功能。
#
# 默认情况下，min-slaves-to-write 设置为 0（功能禁用），
# min-slaves-max-lag 设置为 10。

################################## 安全性 ###################################

# 要求客户端在处理任何其他命令之前发出 AUTH <PASSWORD>。
# 这在你不信任其他人访问运行 redis-server 的主机的环境中可能很有用。
#
# 为了向后兼容，这应该保持注释状态，因为大多数人不需要身份验证（例如，他们运行自己的服务器）。
# 
# 警告：由于 Redis 非常快，外部用户可以在一个好的盒子上每秒尝试 150k 个密码。
# 这意味着你应该使用非常强的密码，否则很容易被破解。
#
# requirepass foobared

# 命令重命名。
#
# 可以在共享环境中更改危险命令的名称。例如，CONFIG 命令可以重命名为难以猜测的名称，
# 以便它仍然可用于内部使用工具，但不适用于一般客户端。
#
# 示例：
#
# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
#
# 也可以通过将命令重命名为空字符串来完全杀死命令：
#
# rename-command CONFIG ""
#
# 请注意，更改记录到 AOF 文件或传输到从服务器的命令的名称可能会导致问题。

################################### 限制 ####################################

# 设置同时连接的最大客户端数。默认情况下，此限制设置为 10000 个客户端，
# 但如果 Redis 服务器无法将进程文件限制配置为允许指定的限制，
# 则允许的最大客户端数设置为当前文件限制减去 32（因为 Redis 保留一些文件描述符供内部使用）。
#
# 一旦达到限制，Redis 将关闭所有新连接，发送错误 'max number of clients reached'。
#
# maxclients 10000

# 如果 Redis 用作仅内存缓存，没有任何持久性，则后台 AOF/RDB 持久性使用的 fork() 机制是不必要的。
# 作为优化，可以在 Windows 版本的 Redis 中关闭所有持久性。
# 这将将堆分配重定向到系统堆分配器，并禁用否则会导致 fork() 操作的命令：BGSAVE 和 BGREWRITEAOF。
# 此标志不能与配置 AOF 和 RDB 操作的其他标志组合使用。
# persistence-available [(yes)|no]

# 不要使用超过指定字节数的内存。
# 当达到内存限制时，Redis 将尝试根据选择的驱逐策略删除键（参见 maxmemory-policy）。
#
# 如果 Redis 无法根据策略删除键，或者策略设置为 'noeviction'，
# Redis 将开始对使用更多内存的命令（如 SET、LPUSH 等）回复错误，
# 并继续回复只读命令（如 GET）。
#
# 此选项通常在将 Redis 用作 LRU 缓存或为实例设置硬内存限制（使用 'noeviction' 策略）时有用。
#
# 警告：如果你有从服务器附加到启用了 maxmemory 的实例，
# 则从服务器所需的输出缓冲区的大小将从使用的内存计数中减去，
# 因此网络问题/重新同步不会触发一个循环，其中键被驱逐，
# 反过来从服务器的输出缓冲区充满了被驱逐键的 DEL，触发更多键的删除，
# 依此类推，直到数据库完全清空。
#
# 简而言之...如果你有从服务器附加，建议你为 maxmemory 设置较低的限制，
# 以便系统上有一些空闲 RAM 用于从服务器输出缓冲区（但如果策略是 'noeviction'，则不需要）。
#
# 警告：不设置 maxmemory 将导致 Redis 在达到堆限制时因内存不足异常而终止。
#
# 注意：由于 Redis 使用系统分页文件来分配堆内存，
# Windows 任务管理器或其他工具（如 ProcessExplorer）显示的工作集内存使用情况并不总是准确的。
# 例如，在 RDB 或 AOF 文件的后台保存后，工作集值可能会显著下降。
# 要检查 redis-server 用于存储数据的内存量，请使用 INFO 客户端命令。
# INFO 命令仅显示用于存储 Redis 数据的内存，而不是 Windows 进程用于其自身需求的额外内存。
# 未由 INFO 命令报告的额外内存量可以通过从 Windows 任务管理器报告的峰值工作集减去 INFO 命令报告的 used_memory_peak 来计算。
#
# maxmemory <bytes>

# MAXMEMORY 策略：当达到 maxmemory 时，Redis 将如何选择要删除的内容。
# 你可以选择五种行为：
# 
# volatile-lru -> 使用 LRU 算法删除设置了过期时间的键
# allkeys-lru -> 根据 LRU 算法删除任何键
# volatile-random -> 随机删除设置了过期时间的键
# allkeys-random -> 随机删除任何键
# volatile-ttl -> 删除最接近过期时间的键（较小的 TTL）
# noeviction -> 根本不删除，只是在写操作时返回错误
# 
# 注意：使用上述任何策略时，当没有合适的键可以驱逐时，Redis 将在写操作时返回错误。
#
# 在撰写本文时，这些命令是：set setnx setex append
# incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
# sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
# zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
# getset mset msetnx exec sort
#
# 默认值为：
#
# maxmemory-policy noeviction

# LRU 和最小 TTL 算法不是精确算法，而是近似算法（为了节省内存），
# 因此你也可以选择样本大小进行检查。例如，默认情况下 Redis 将检查三个键，
# 并选择最近使用较少的键，你可以使用以下配置指令更改样本大小。
#
# maxmemory-samples 3

############################## 仅追加模式 ###############################

# 默认情况下，Redis 异步将数据集转储到磁盘。此模式在许多应用程序中足够好，
# 但 Redis 进程的问题或电源故障可能导致几分钟的写入丢失（取决于配置的保存点）。
#
# 仅追加文件是一种替代持久性模式，提供更好的持久性。例如，使用默认的数据 fsync 策略
#（参见配置文件后面的内容），Redis 在服务器电源故障等严重事件中可能只丢失一秒钟的写入，
# 或者在 Redis 进程本身发生问题但操作系统仍在正常运行的情况下丢失一次写入。
#
# AOF 和 RDB 持久性可以同时启用而不会出现问题。
# 如果在启动时启用了 AOF，Redis 将加载 AOF，即具有更好持久性保证的文件。
#
# 请查看 http://redis.io/topics/persistence 获取更多信息。

appendonly no

# 仅追加文件的名称（默认："appendonly.aof"）
appendfilename "appendonly.aof"

# fsync() 调用告诉操作系统实际将数据写入磁盘，而不是等待输出缓冲区中的更多数据。
# 一些操作系统会真正将数据刷新到磁盘，而其他操作系统只会尽快尝试这样做。
#
# Redis 支持三种不同的模式：
#
# no: 不 fsync，只是让操作系统在想要时刷新数据。更快。
# always: 每次写入仅追加日志后 fsync。较慢，最安全。
# everysec: 每秒仅 fsync 一次。折衷。
#
# 默认值为 "everysec"，因为这通常是速度和数据安全性之间的正确折衷。
# 由你决定是否可以将其放宽为 "no"，这将让操作系统在想要时刷新输出缓冲区，
# 以获得更好的性能（但如果你能接受一些数据丢失，请考虑默认的持久性模式，即快照），
# 或者相反，使用 "always"，这非常慢，但比 everysec 更安全。
#
# 更多详细信息，请查看以下文章：
# http://antirez.com/post/redis-persistence-demystified.html
#
# 如果不确定，请使用 "everysec"。

# appendfsync always
appendfsync everysec
# appendfsync no

# 当 AOF fsync 策略设置为 always 或 everysec，并且后台保存进程
#（后台保存或 AOF 日志后台重写）对磁盘执行大量 I/O 时，
# 在某些 Linux 配置中，Redis 可能会在 fsync() 调用上阻塞太长时间。
# 请注意，目前没有修复方法，因为即使在不同的线程中执行 fsync 也会阻塞我们的同步 write(2) 调用。
#
# 为了缓解此问题，可以使用以下选项，以防止在主进程中调用 fsync()，
# 而 BGSAVE 或 BGREWRITEAOF 正在进行中。
#
# 这意味着当另一个子进程正在保存时，Redis 的持久性与 "appendfsync none" 相同。
# 实际上，这意味着在最坏的情况下（使用默认的 Linux 设置）可能会丢失最多 30 秒的日志。
# 
# 如果你有延迟问题，请将其设置为 "yes"。否则，请将其保留为 "no"，这是从持久性角度来看最安全的选择。
no-appendfsync-on-rewrite no

# 自动重写仅追加文件。
# Redis 能够在 AOF 日志大小增长到指定百分比时自动重写日志文件，隐式调用 BGREWRITEAOF。
# 
# 工作原理：Redis 记住最新重写后的 AOF 文件大小（如果自重启以来未发生重写，则使用启动时的 AOF 大小）。
#
# 将此基本大小与当前大小进行比较。如果当前大小大于指定百分比，则触发重写。
# 你还需要指定 AOF 文件的最小大小以进行重写，这对于即使达到百分比增加但仍然很小的情况避免重写 AOF 文件很有用。
#
# 指定百分比为零以禁用自动 AOF 重写功能。

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 在 Redis 启动过程中，当 AOF 数据加载回内存时，可能会发现 AOF 文件在末尾被截断。
# 这可能发生在运行 Redis 的系统崩溃时，特别是在 ext4 文件系统挂载时未使用 data=ordered 选项
#（但是当 Redis 本身崩溃或中止但操作系统仍在正常运行时，这不会发生）。
#
# Redis 可以在此情况下退出并显示错误，或者加载尽可能多的数据（现在是默认值）并在发现 AOF 文件在末尾被截断时启动。
# 以下选项控制此行为。
#
# 如果 aof-load-truncated 设置为 yes，则加载截断的 AOF 文件，并且 Redis 服务器开始发出日志以通知用户该事件。
# 否则，如果选项设置为 no，服务器将中止并显示错误并拒绝启动。
# 当选项设置为 no 时，用户需要在重新启动服务器之前使用 "redis-check-aof" 实用程序修复 AOF 文件。
#
# 请注意，如果 AOF 文件在中间被发现损坏，服务器仍将退出并显示错误。
# 此选项仅适用于 Redis 尝试从 AOF 文件读取更多数据但未找到足够字节的情况。
aof-load-truncated yes

################################ LUA 脚本  ###############################

# Lua 脚本的最大执行时间（以毫秒为单位）。
#
# 如果达到最大执行时间，Redis 将记录脚本仍在执行，并在允许的最大时间后开始回复查询错误。
#
# 当长时间运行的脚本超过最大执行时间时，只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 命令可用。
# 第一个可用于停止尚未调用写命令的脚本。第二个是在脚本已发出写命令但用户不想等待脚本自然终止的情况下关闭服务器的唯一方法。
#
# 将其设置为 0 或负值以无警告地无限执行。
lua-time-limit 5000

################################ REDIS 集群  ###############################
#
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# 警告实验性：Redis 集群被认为是稳定的代码，但为了将其标记为“成熟”，我们需要等待相当比例的用户在生产中部署它。
# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
# 普通的 Redis 实例不能成为 Redis 集群的一部分；只有作为集群节点启动的节点才能。
# 要将 Redis 实例作为集群节点启动，请取消注释以下内容以启用集群支持：
#
# cluster-enabled yes

# 每个集群节点都有一个集群配置文件。此文件不打算手动编辑。它由 Redis 节点创建和更新。
# 每个 Redis 集群节点需要一个不同的集群配置文件。
# 确保在同一系统中运行的实例没有重叠的集群配置文件名。
#
# cluster-config-file nodes-6379.conf

# 集群节点超时是节点必须不可达的时间量（以毫秒为单位），才能被视为故障状态。
# 大多数其他内部时间限制是节点超时的倍数。
#
# cluster-node-timeout 15000

# 故障主服务器的从服务器将避免启动故障转移，如果其数据看起来太旧。
#
# 从服务器实际上没有简单的方法来精确测量其“数据年龄”，因此执行以下两项检查：
#
# 1) 如果有多个从服务器能够进行故障转移，它们交换消息以尝试给具有最佳复制偏移量的从服务器（处理了更多来自主服务器的数据）一个优势。
#    从服务器将尝试通过偏移量获得其排名，并在故障转移开始时应用与其排名成比例的延迟。
#
# 2) 每个从服务器计算与主服务器的最后一次交互的时间。这可以是最后一次 PING 或接收的命令（如果主服务器仍处于“连接”状态），
#    或者自与主服务器断开连接以来经过的时间（如果复制链接当前已关闭）。
#    如果最后一次交互太旧，从服务器将根本不尝试故障转移。
#
# 点 "2" 可以由用户调整。具体来说，如果自与主服务器的最后一次交互以来经过的时间大于以下值，则从服务器将不执行故障转移：
#
#   (node-timeout * slave-validity-factor) + repl-ping-slave-period
#
# 例如，如果节点超时为 30 秒，从服务器有效性因子为 10，并假设默认的 repl-ping-slave-period 为 10 秒，
# 则如果从服务器无法与主服务器通信超过 310 秒，它将不尝试故障转移。
#
# 较大的从服务器有效性因子可能允许具有太旧数据的从服务器对主服务器进行故障转移，
# 而太小的值可能阻止集群能够选举从服务器。
#
# 为了获得最大可用性，可以将从服务器有效性因子设置为 0，这意味着从服务器将始终尝试对主服务器进行故障转移，
# 无论它们与主服务器的最后一次交互是什么时候。
#（然而，它们总是尝试应用与其偏移量排名成比例的延迟）。
#
# 零是唯一能够保证在所有分区恢复时集群始终能够继续的值。
#
# cluster-slave-validity-factor 10

# 集群从服务器能够迁移到孤立的主服务器，即没有工作从服务器的主服务器。
# 这提高了集群抵抗故障的能力，因为否则在故障情况下，如果没有工作从服务器，孤立的主服务器无法进行故障转移。
#
# 从服务器仅在旧主服务器仍有至少给定数量的其他工作从服务器时迁移到孤立的主服务器。
# 此数量是“迁移屏障”。迁移屏障为 1 意味着从服务器仅在旧主服务器仍有至少 1 个其他工作从服务器时迁移，依此类推。
# 它通常反映你希望集群中每个主服务器拥有的从服务器数量。
#
# 默认值为 1（从服务器仅在旧主服务器仍有至少一个从服务器时迁移）。要禁用迁移，只需将其设置为非常大的值。
# 可以设置为 0，但仅对调试有用，在生产中很危险。
#
# cluster-migration-barrier 1

# 默认情况下，如果 Redis 集群节点检测到至少有一个哈希槽未被覆盖（没有可用节点为其提供服务），
# 它们将停止接受查询。这样，如果集群部分关闭（例如，一系列哈希槽不再被覆盖），
# 整个集群最终将变得不可用。一旦所有槽再次被覆盖，它将自动恢复可用。
#
# 然而，有时你希望集群的工作子集继续接受仍然覆盖的键空间的查询。
# 为此，只需将 cluster-require-full-coverage 选项设置为 no。
#
# cluster-require-full-coverage yes

# 要设置你的集群，请确保阅读 http://redis.io 网站上的文档。

################################## 慢日志 ###################################

# Redis 慢日志是一个记录超过指定执行时间的查询的系统。
# 执行时间不包括 I/O 操作，如与客户端交谈、发送回复等，
# 而只是实际执行命令所需的时间（这是命令执行的唯一阶段，线程被阻塞，无法同时服务其他请求）。
# 
# 你可以使用两个参数配置慢日志：一个告诉 Redis 执行时间（以微秒为单位）超过多少才记录命令，
# 另一个参数是慢日志的长度。当记录新命令时，最旧的命令将从记录的命令队列中删除。

# 以下时间以微秒表示，因此 1000000 相当于一秒。请注意，负数禁用慢日志，而零值强制记录每个命令。
slowlog-log-slower-than 10000

# 此长度没有限制。只需注意它将消耗内存。你可以使用 SLOWLOG RESET 回收慢日志使用的内存。
slowlog-max-len 128

################################ 延迟监控 ##############################

# Redis 延迟监控子系统在运行时对不同的操作进行采样，以收集与 Redis 实例可能的延迟源相关的数据。
#
# 通过 LATENCY 命令，用户可以打印图表并获取报告。
#
# 系统仅记录执行时间等于或大于通过 latency-monitor-threshold 配置指令指定的毫秒数的操作。
# 当其值设置为零时，延迟监控关闭。
#
# 默认情况下，延迟监控被禁用，因为如果你没有延迟问题，通常不需要它，
# 并且收集数据会对性能产生影响，虽然非常小，但在大负载下可以测量。
# 如果需要，可以使用命令 "CONFIG SET latency-monitor-threshold <milliseconds>" 在运行时轻松启用延迟监控。
latency-monitor-threshold 0

############################# 事件通知 ##############################

# Redis 可以通知 Pub/Sub 客户端有关键空间中发生的事件。
# 此功能记录在 http://redis.io/topics/notifications
#
# 例如，如果启用了键空间事件通知，并且客户端对存储在数据库 0 中的键 "foo" 执行 DEL 操作，
# 将通过 Pub/Sub 发布两条消息：
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# 可以选择 Redis 将通知的事件类别。每个类别由单个字符标识：
#
#  K     键空间事件，以 __keyspace@<db>__ 前缀发布。
#  E     键事件事件，以 __keyevent@<db>__ 前缀发布。
#  g     通用命令（非类型特定），如 DEL、EXPIRE、RENAME 等。
#  $     字符串命令
#  l     列表命令
#  s     集合命令
#  h     哈希命令
#  z     有序集合命令
#  x     过期事件（每次键过期时生成的事件）
#  e     驱逐事件（当键因 maxmemory 被驱逐时生成的事件）
#  A     g$lshzxe 的别名，因此 "AKE" 字符串表示所有事件。
#
#  "notify-keyspace-events" 接受由零个或多个字符组成的字符串作为参数。空字符串表示通知被禁用。
#
#  示例：要启用列表和通用事件，从事件名称的角度，使用：
#
#  notify-keyspace-events Elg
#
#  示例 2：要获取过期键的流，订阅频道名称 __keyevent@0__:expired，使用：
#
#  notify-keyspace-events Ex
#
#  默认情况下，所有通知都被禁用，因为大多数用户不需要此功能，并且该功能有一些开销。
#  请注意，如果你未指定至少一个 K 或 E，则不会传递任何事件。
notify-keyspace-events ""

############################### 高级配置 ###############################

# 哈希在具有少量条目且最大条目不超过给定阈值时使用内存高效的数据结构进行编码。
# 可以使用以下指令配置这些阈值。
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# 类似于哈希，小列表也以特殊方式编码以节省大量空间。
# 仅当你在以下限制下时才使用特殊表示：
list-max-ziplist-entries 512
list-max-ziplist-value 64

# 集合在一种情况下具有特殊编码：当集合由恰好是 64 位有符号整数范围内的字符串组成时。
# 以下配置设置设置集合的大小限制以使用此特殊内存节省编码。
set-max-intset-entries 512

# 类似于哈希和列表，有序集合也以特殊方式编码以节省大量空间。
# 仅当有序集合的长度和元素低于以下限制时才使用此编码：
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# HyperLogLog 稀疏表示字节限制。限制包括 16 字节头。
# 当使用稀疏表示的 HyperLogLog 超过此限制时，它将转换为密集表示。
#
# 大于 16000 的值完全无用，因为在这一点上密集表示更节省内存。
#
# 建议值为 ~ 3000，以便在不显著减慢 PFADD 的情况下获得空间高效编码的好处，
# 使用稀疏编码时 PFADD 是 O(N)。当 CPU 不是问题但空间是问题时，
# 并且数据集由许多基数在 0 - 15000 范围内的 HyperLogLog 组成时，可以将值提高到 ~ 10000。
hll-sparse-max-bytes 3000

# 主动重新哈希每 100 毫秒 CPU 时间使用 1 毫秒来帮助重新哈希主 Redis 哈希表（将顶级键映射到值的表）。
# Redis 使用的哈希表实现（参见 dict.c）执行惰性重新哈希：你对正在重新哈希的哈希表运行的操作越多，
# 执行的重新哈希“步骤”越多，因此如果服务器空闲，重新哈希永远不会完成，哈希表会使用更多内存。
# 
# 默认情况下，每秒使用此毫秒 10 次以主动重新哈希主字典，尽可能释放内存。
#
# 如果不确定：
# 如果你有严格的延迟要求，并且在你环境中 Redis 偶尔以 2 毫秒延迟回复查询不是好事，请使用 "activerehashing no"。
#
# 如果你没有如此严格的要求，但希望尽可能快地释放内存，请使用 "activerehashing yes"。
activerehashing yes

# 客户端输出缓冲区限制可用于强制断开由于某种原因未从服务器快速读取数据的客户端
#（常见原因是 Pub/Sub 客户端无法像发布者生成消息那样快地消费消息）。
#
# 可以为三种不同类型的客户端设置不同的限制：
#
# normal -> 普通客户端，包括 MONITOR 客户端
# slave  -> 从服务器客户端
# pubsub -> 订阅至少一个 pubsub 频道或模式的客户端
#
# 每个 client-output-buffer-limit 指令的语法如下：
#
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# 一旦达到硬限制，客户端将立即断开连接，或者如果达到软限制并持续达到指定的秒数（连续）。
# 因此，例如，如果硬限制为 32 兆字节，软限制为 16 兆字节 / 10 秒，
# 如果输出缓冲区的大小达到 32 兆字节，客户端将立即断开连接，
# 但如果客户端达到 16 兆字节并持续超过限制 10 秒，也将断开连接。
#
# 默认情况下，普通客户端不受限制，因为它们不会以推送方式接收数据，
# 而只是在请求后接收数据，因此只有异步客户端可能会创建数据请求速度超过读取速度的场景。
#
# 相反，pubsub 和从服务器客户端有默认限制，因为订阅者和从服务器以推送方式接收数据。
#
# 通过将它们设置为零，可以禁用硬限制或软限制。
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Redis 调用内部函数来执行许多后台任务，如关闭超时的客户端连接、清除从未请求的过期键等。
#
# 并非所有任务都以相同的频率执行，但 Redis 根据指定的 "hz" 值检查要执行的任务。
#
# 默认情况下，"hz" 设置为 10。提高该值将在 Redis 空闲时使用更多 CPU，
# 但同时将使 Redis 在有许多键同时过期时更具响应性，并且可以更精确地处理超时。
#
# 范围在 1 到 500 之间，但通常不建议使用超过 100 的值。
# 大多数用户应使用默认值 10，并仅在需要非常低延迟的环境中将其提高到 100。
hz 10

# 当子进程重写 AOF 文件时，如果启用以下选项，则每生成 32 MB 数据时将对文件进行 fsync。
# 这对于更增量地将文件提交到磁盘并避免大的延迟峰值很有用。
aof-rewrite-incremental-fsync yes

################################## 包含文件 ###################################

# 在此处包含一个或多个其他配置文件。如果你有一个标准的模板适用于所有 Redis 服务器，
# 但还需要自定义一些每个服务器的设置，这将非常有用。包含文件可以包含其他文件，
# 因此请明智地使用此功能。
#
# include /path/to/local.conf
# include /path/to/other.conf